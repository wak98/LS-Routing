import sys
from collections import defaultdict
from router import Router
from packet import Packet
from json import dumps, loads
from dijkstar import Graph, find_path

class LSrouter(Router):
    """Link state routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0
        self.forwarding_table = {}
        self.routing_table = {}
        self.graph = Graph()
        self.seqno = "1"
        self.check = True
        # Hints: initialize local state
        pass


    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""
        if packet.isTraceroute():
            # Hints: this is a normal data packet
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            for x,y in self.forwarding_table.items():
                if packet.dstAddr == x:
                    first = int(y.split(" ")[0],10)
                    self.send(first,packet)
            
            try:
                var = find_path(self.graph, self.addr, packet.dstAddr)
                if var.total_cost > 1:
                    for x,y in self.forwarding_table.items():
                        temp = var.nodes[1]
                        if x == temp:
                            first = int(y.split(" ")[0],10)
                            self.send(first , packet)
            except:
                pass

        else:

            #   Hints: this is a routing packet generated by your routing protocol
            #   check the sequence number
            #   if the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors

            rec = packet.content.split(" ",1)
            temp = rec[0]
            seqno_received = int(temp,10)

            received_routing_table = loads(packet.content.split(" ",1)[1])

            if self.addr == packet.srcAddr:
                return

            for x,y in self.routing_table.items():
                if x == packet.srcAddr:
                    if y >= seqno_received:
                        return

            for x,y in self.forwarding_table.items():
                if ord(x) <= 90:
                    temp = y.split(" ")[0]
                    t = int(temp,10)
                    if not port==t:
                        self.send(t,packet) 

            try:
                for x in self.graph[packet.srcAddr]:
                    if self.graph[packet.srcAddr][x] == packet.srcAddr:
                        continue
                    Check = False
                    for y in received_routing_table.keys():
                        if x == y:
                            Check = True
                            break

                    if Check == False:
                        self.graph.remove_edge(packet.srcAddr, x)            
            except:
                pass

            for x in received_routing_table.keys():
                self.graph.add_edge(packet.srcAddr , x, int(received_routing_table[x].split(" ")[1],10))

            self.routing_table[packet.srcAddr] = seqno_received
            


    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        self.graph.add_edge(self.addr , endpoint, cost)
        self.forwarding_table[endpoint]= str(port)  + " " + str(cost)

        for x,y in self.forwarding_table.items():
            if ord(x) < 90:
                temp = self.forwarding_table[endpoint].split(" ")[0]
                t = int(temp,10)
                port = t
                jsn_str = dumps(self.forwarding_table)
                t_str = self.seqno + " " + jsn_str
                pac = Packet(Packet.ROUTING, self.addr, port,t_str)
                self.send(port, pac)
                t_int = int(self.seqno,10)
                self.seqno = str(t_int+1)

    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        for x,y in self.forwarding_table.items():
            temp = y.split(" ")[0]
            to_rmv = int(temp,10)
            if port == to_rmv:
                break     
        self.forwarding_table.pop(x,None)
        self.graph.remove_edge(self.addr, x)

        for x,y in self.forwarding_table.items():
            if ord(x) < 90:
                pac = y.split(" ")[0]
                port = int(pac,10)
                jsn = dumps(self.forwarding_table)
                t_str = self.seqno + " " + jsn
                pkg = Packet(Packet.ROUTING,self.addr,port,t_str) 
                self.send(port,pkg)
                t_int = int(self.seqno,10)
                self.seqno = str(t_int+1)


    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs
            # Hints:
            # broadcast the link state of this router to all neighbors
            for x,y in self.forwarding_table.items():
                if ord(x) < 90:
                    temp = y.split(" ")[0]
                    port = int(temp,10)
                    jsn = dumps(self.forwarding_table)
                    t_str = self.seqno + " " + jsn
                    pac = Packet(Packet.ROUTING, self.addr, port , t_str)
                    self.send(port,  pac)

    def debugString(self):
        """TODO: generate a string for debugging in network visualizer"""
        print("Address: ",self.addr)
        print("Routing Table: ",self.routing_table)
        print("Forwarding Table: ",self.forwarding_table)
        print("Graph : ", self.graph)
        print()
        try:
            print(find_path(self.graph, "a" , "b"))
        except:
            pass
        return ""